<!--
@license
Copyright 2017 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<link rel="import" href="trace_viewer_full.html" />

<!--
If WebComponents V0 are not available, show a warning regarding Polymer and
Trace Viewer.
-->
<style>
  html, body {
    font-size: 14px;
    font-weight: 400;
    line-height: 20px;
  }

  .no-webcomponents-container.hidden {
    display: none;
  }

  .no-webcomponents-container {
    display: flex;
    justify-content: center;
    margin-top: 80px;
    font-family: Roboto, sans-serif;
  }

  .no-webcomponents-container .title {
    font-size: 22px;
    font-weight: bold;
  }

  .no-webcomponents-container .contents {
    max-width: 600px;
  }

  #event-details {
    float: right;
    display: flex;
    min-width: 30%;
    background-color: #ececec;
  }

  tr-ui-b-tab-view {
    float: left;
    flex: 1;
  }

  #analysis {
    flex-flow: row nowrap;
  }

  #eventSummaryTable table.tr-ui-b-table {
    /* Make text content wrap when the container resizes. */
    overflow-wrap: anywhere;

    /* Table layout fixed is needed since otherwise the td element's width don't
     * get calculated properly for `resize: horizontal`. We set width to 100% so the table still
     * dynamically reflows based on window width. */
    table-layout:fixed;
    width: 100%;
  }

  /* Columns in Event Summary Table. */
  #eventSummaryTable thead.tr-ui-b-table > tr.tr-ui-b-table > td.tr-ui-b-table {
    /* Allow Event Summary Table Columns width to be resizable */
    resize: horizontal;
    min-width: 100px;
  }

  /* Name Column in Event Summary Table. */
  #eventSummaryTable thead.tr-ui-b-table > tr.tr-ui-b-table > td.tr-ui-b-table:first-child {
    min-width: 350px;
    width: 500px;
    max-width: 900px;
  }

  #eventSummaryTable tr-ui-a-analysis-link {
    /* Override Catapult CSS which sets this as no-wrap preventing resizing the HTML element. */
    white-space: normal;
  }

  #trace-filter-config .checkboxes {
    padding-left: 0;
  }

  #trace-filter-config .delete-btn {
    margin-right: 10px;
    background: #ee390b;
  }

  #trace-filter-config ul {
    list-style: none;
  }

  #trace-filter-config li {
    list-style: none;
  }

  #trace-filter-config #device-resource-filter {
    border: 0.5px solid;
    width: 300px;
    padding: 10px;
  }

  #trace-filter-config details {
      border: 1px solid #aaa;
      border-radius: 4px;
      padding: .5em .5em 0;
      width: 500px;
  }
</style>

<div class="no-webcomponents-container hidden">
  <div class="contents">
    <div class="title">The trace viewer is currently unavailable.</div>
    <p>
      For more details, see
      <a
        href="https://github.com/tensorflow/tensorboard/issues/3209"
        rel="noopener"
        target="_blank"
        >this issue</a
      >.
    </p>
    <br />
    <br />
    <p>
      If you are running a Chromium-based browser, one workaround is to download
      your data as JSON and load it in your browser's viewer at
      "about://tracing". This run's data can be found here:
    </p>
  </div>
</div>

<script>
  const canUseWebComponentsV0 =
    typeof document.registerElement === 'function' &&
    typeof Element.prototype.createShadowRoot === 'function';
  if (!canUseWebComponentsV0) {
    const containerEl = document.querySelector('.no-webcomponents-container');
    const contentsEl = document.querySelector(
      '.no-webcomponents-container .contents'
    );
    containerEl.classList.remove('hidden');

    const currentURL = new URL(window.location.href);
    const relativeTraceURL = currentURL.searchParams.get('trace_data_url');
    const traceURL = new URL(relativeTraceURL, window.location.href).toString();

    const profileDataLink = document.createElement('i');
    profileDataLink.textContent = `${traceURL}`;
    contentsEl.appendChild(profileDataLink);
  }
</script>

<!--
tf-trace-viewer is the frontend entry point for Trace Viewer on TensorBoard.

The server serves the trace viewer app at a separate endpoint. TensorBoard
dashboard would integrate trace viewer app using iframe.
-->
<style>
  tr-ui-timeline-view {
    position: absolute;
    width: 100%;
    height: 100%;
  }
  /* The "throbber": a spinning loading indicator */
  @keyframes spin {
    to {
      transform: rotate(1turn);
    }
  }
  #throbber {
    animation: spin 1s infinite linear;
    color: black;
    font-size: 256px;
    /* Display in the upper center of the screen */
    position: fixed;
    z-index: 10;
    top: 200px;
    left: 50%;
    width: 256px;
    margin-left: -128px;
    /* Center within that box */
    line-height: 256px;
    text-align: center;
    pointer-events: none;

    opacity: 0;
    transition: opacity 0.3s ease-in-out;
  }
  #throbber.active {
    opacity: 0.15;
    /* Wait a short time before showing the throbber (no delay for hiding). */
    transition-delay: 0.3s;
  }
</style>
<script src="tf-trace-viewer-helper.js"></script>
<script>
  'use strict';

  class TraceEventFilter {
    constructor(field, negation, op, value, type) {
      this.field = field;
      this.negation = negation;
      this.op = op;
      this.value = value;
      this.type = type;
    }

    toString() {
      const operators = ['=', '<', '>', '<=', '>='];
      return `${this.field} ${this.negation ? 'NOT' : ''} ${operators[this.op]} ${this.value}  |  type: ${this.type}`;
    }

    toJSON() {
      let json = {'field': this.field, 'negation': this.negation, 'op': this.op};

      switch(this.type) {
        case 'str':
          json.str_value = this.value;
          break;
        case 'regex':
          json.regex_value = this.value;
          break;
        case 'uint':
          json.uint_value = this.value;
          break;
        case 'int':
          json.int_value = this.value;
          break;
        case 'double':
          json.double_value = this.value;
          break;
      }

      return json;
    }
  }

  class TraceFilter {
    constructor() {
      this.device_regexes = [];
      this.resource_regexes = [];
      this.trace_event_filters = [];
      this.trace_event_arg_filters = [];
      this.negation = false;
    }
  }

  class TraceFilterConfig {
    constructor() {
      this.trace_filters = [];
    }
  }

  const traceFilterHTMLTemplate = `
    <details>
        <summary>TraceFilter</summary>
    <div id="device-resource-filter">

    <form class="device-regex-form">
      <p>Matches Device Regexes</p>
      <ul id="device-regex-list" class="checkboxes">
      </ul>
      <input type="text">
      <input type="submit" value="Add Device Regex">
    </form>

    <form class="resource-regex-form">
      <p>Matches Resource Regexes</p>
      <ul id="device-regex-list" class="checkboxes">
      </ul>
      <input type="text" placeholder="">
      <input type="submit" value="Add Resource Regex">
    </form>

    </div>

    <form class="event-regex-form">
      <h4>Event Filter</h4>
      Events that match the filter are filtered out.

      <ul class="checkboxes">
      </ul>
      <input type="text" id="field" name="field" placeholder="event field">

      <select id="negation" name="negation">
        <option value="0"></option>
        <option value="1">NOT</option>
      </select>

      <select id="operator" name="operator">
        <option value="0">=</option>
        <option value="1"><</option>
        <option value="2">></option>
        <option value="3"><=</option>
        <option value="4">>=</option>
      </select>

      <input type="text" id="value" name="value" placeholder="value">

      <br>

      <label for="value_type">Value Type:</label>
      <select id="value_type" name="value_type">
        <option value="str">string</option>
        <option value="regex">regex</option>
        <option value="uint">uint</option>
        <option value="int">int</option>
        <option value="double">double</option>
      </select>

      <input type="submit" value="Add Event Filter">
    </form>

    <form class="event-arg-regex-form">
      <h4>Event Arg Filter</h4>
      Event Args that match the filter are filtered out.

      <ul class="checkboxes">
      </ul>
      <input type="text">
      <input type="submit" value="Add Event Arg Filter">
    </form>

    <ul class="checkboxes">
      <li><input type="checkbox" class="invert-tracefilter">Invert TraceFilter</li>
      <p>By default, TraceFilter will filter out events that don't match it. Checking this box means TraceFilter will instead filter out events that match it.</p>
    </ul>

    <input type="submit" value="Delete TraceFilter" class="delete-tracefilter">

    </details>
  `;

  /* tf-trace-viewer will work in two modes: static mode and streaming mode.
   * in static mode, data are load at 'ready' time,
   * in streaming mode, data are load on demand when resolution and view port is changed.
   * static mode limit the amount of trace that we can collect and show to the users.
   */
  Polymer({
    is: 'tf-trace-viewer',
    properties: {
      // The URL of hosts data. Provided by caller via URL parameter.
      hostsDataUrl: {
        type: String,
        value: null,
      },
      // The URL of trace data. Provided by caller via URL parameter.
      traceDataUrl: {
        type: String,
        value: null,
      },
      // _traceData is used for static mode.
      _traceData: {
        type: Object,
        observer: '_traceDataChanged',
      },
      _traceViewer: Object,
      _traceContainer: Object,
      _traceModel: Object,
      _throbber: Object,
      _eventDetails: Object,
      _isStreaming: {type: Boolean, value: false},
      _loadedRange: Object,
      _loadedTraceEents: Object,
      _fullBounds: Object,
      _isLoading: {type: Boolean, value: false},
      _dirty: {type: Boolean, value: false},
      _model: Object,
      _resolution: {type: Number, value: 1000},
      _dataRegenerated: {type: Boolean, value: false},
    },

    ready: function() {
      // Initiate the trace viewer app.
      this._traceContainer = document.createElement('track-view-container');
      this._traceContainer.id = 'track_view_container';

      this._traceViewer = document.createElement('tr-ui-timeline-view');
      this._traceViewer.track_view_container = this._traceContainer;
      Polymer.dom(this._traceViewer).appendChild(this._traceContainer);

      this._traceViewer.brushingStateController.addEventListener(
        'change', this.onSelectionChange.bind(this));

      // Override the default behavior for find fitler such that pressing find
      // previous, find next which cycles through events in the search filter results
      // will zoom and focus the event in the timeline.
      const boundFindFocusChanged =
          this._traceViewer.brushingStateController.findFocusChangedTo.bind(
              this._traceViewer.brushingStateController);
      this._traceViewer.brushingStateController.findFocusChangedTo =
          (currentFocus) => {
            boundFindFocusChanged(currentFocus);
            this._traceViewer.trackView.zoomToSelection();
          };

      this._traceViewer.id = 'trace-viewer';
      this._traceViewer.globalMode = false;

      this._throbber = document.createElement('div');
      this._throbber.id = 'throbber';
      Polymer.dom(this._throbber).appendChild(document.createTextNode('↻'));

      Polymer.dom(this.root).appendChild(this._traceViewer);
      Polymer.dom(this.root).appendChild(this._throbber);

      this._resolution = this._resolutionFromViewerWidth(this._traceViewer.clientWidth);
      // Retrieve the URL of trace data.
      var queryString = window.location.href.split('?')[1];
      if (queryString) {
        var parts = queryString.split('&');
        for (var i = 0; i < parts.length; i++) {
          var components = parts[i].split('=');
          if (components[0] == 'trace_data_url') {
            this.traceDataUrl = decodeURIComponent(components[1]);
            if (this.traceDataUrl) {
              try {
                traceViewerLink = new URL(window.location.origin + this.traceDataUrl);
                this._sessionId = traceViewerLink.searchParams.get('session_id');
              } catch(err) {  // not fatal.
                console.log('cannot find session id');
              }
            }
          } else if (components[0] == 'is_streaming') {
            this._isStreaming = components[1] === 'true';
          } else if (components[0] == 'hosts_data_url') {
            this.hostsDataUrl = decodeURIComponent(components[1]);
          }
        }
      }

      if (!this.traceDataUrl) {
        this._displayOverlay('Trace data URL is not provided.', 'Trace Viewer');
        return null;
      }
      if (this._isStreaming) {
        this._loadHosts();
        this._traceViewer.updateProcessList_ = this._updateProcessList.bind(this);
      } else {
        this._loadTrace(null, /* replaceModel= */ true);
      }

      window.addEventListener('load', function(e) {
        element = document.getElementById('analysis');
        // add a vertical divider as child.
        verticalDivider = document.createElement('tr-ui-b-drag-handle');
        element.appendChild(verticalDivider);
        // add a event details pane as child.
        this._eventDetails = document.createElement('div');
        this._eventDetails.id = 'event-details';
        element.appendChild(this._eventDetails);
        // associate divider with event details pane.
        verticalDivider.horizontal = false;
        verticalDivider.target = this._eventDetails;

        // Create Trace Filter Config Dropdown.
        this._createFilterSelector();
      }.bind(this));
    },

    _sessionId: string = '',
    _lastSelectedHloModule: string = '',
    _selectedDeviceIds: null,
    _devices: null,
    _traceFilterConfig: new TraceFilterConfig(),

    onSelectionChange: function(e) {
      if (!this._sessionId) return;
      this._eventDetails.innerHTML = "";
      events = this._traceViewer.brushingStateController.currentBrushingState.selection;
      if (events === undefined) return;
      if (events.length != 1) return;

      for (const event of events) {
        if (event.parentContainer.name === 'XLA Ops') {
          hloOp = event.title;
          const graphViewLink =
                new URL(window.location.origin + '/graph_viewer/' + this._sessionId);
          graphViewLink.searchParams.append("node_name", hloOp);
          if (this._lastSelectedHloModule) {
            graphViewLink.searchParams.append("module_name", this._lastSelectedHloModule);
          }
          module_name = this._lastSelectedHloModule ? this._lastSelectedHloModule : 'default';
          this._eventDetails.innerHTML =
            '<div><a href="' + graphViewLink.href + '" target="_blank"> see hlo graph for ' +
            hloOp + '@' + module_name + '</a>' +
            '<br>Note: Make sure that you have select the correct module by click on it first.' +
            '</div>';
        } else if (event.parentContainer.name === 'XLA Modules') {
          this._lastSelectedHloModule = event.title;
        }
        if ('group_id' in event.args) {
          const traceViewerStepLink =
                new URL(window.location.origin + '/trace_viewer/' + this._sessionId);
          traceViewerStepLink.searchParams.append("selected_group_ids", event.args['group_id']);
          this._eventDetails.innerHTML += '<div><a href="' + traceViewerStepLink.href +
            '" target="_blank"> see events ONLY for this step/group ' +
            event.args['group_id'] + '</div>';
        }
      }
    },

    _createFilters: function(hosts) {
      hosts = hosts || [];
      const hostSelector = document.createElement('select');
      hostSelector.setAttribute('name', 'host');
      hostSelector.setAttribute('id', 'host_selector');

      const option = document.createElement('option');
      option.setAttribute('value', '');
      option.innerText = 'All hosts';
      hostSelector.appendChild(option);

      hosts.forEach(host => {
        const option = document.createElement('option');
        option.setAttribute('value', host);
        option.innerText = host;
        hostSelector.appendChild(option);
      });

      if (hostSelector.children.length <= 2) {
        hostSelector.hidden = true;
      } else {
        // children[0] is all hosts.
        hostSelector.children[1].selected = 'selected';
      }
      hostSelector.addEventListener("change", () => {
        // When the host changes, we need to clear the Process Filter Dropdown
        // since it contains devices (pids) associated with the previous host.
        this._clearProcessList();
        this._loadTrace(null, /* replaceModel= */ true);  // reload data.
      });

      Polymer.dom(this._traceViewer.leftControls).appendChild(hostSelector);

      const detailsSelector = document.createElement('tr-ui-b-dropdown');
      detailsSelector.setAttribute('id', 'details_selector');
      detailsSelector.style.display = 'none';
      Polymer.dom(this._traceViewer.leftControls).appendChild(detailsSelector);
    },

    _loadHosts: function() {
      if (!this.hostsDataUrl) {
        this._createFilters([]);
        this._loadTrace(null, /* replaceModel= */ true);
        return;
      }

      const req = new XMLHttpRequest();
      req.open('GET', this.hostsDataUrl, true);

      req.onreadystatechange = (event) => {
        if (req.readyState !== 4) {
          return;
        }
        window.setTimeout(() => {
          if (req.status === 200) {
            this._createFilters(JSON.parse(req.responseText));
            this._loadTrace(null, /* replaceModel= */ true);
          } else {
            this._displayOverlay(req.status, 'Failed to fetch data');
          }
        }, 0);
      };
      req.send(null);
    },

    _loadTrace: function(requestedRange, replaceModel) {
      this._throbber.className = 'active';
      if (!this._isStreaming) {
        // Send HTTP request to get the trace data.
        var req = new XMLHttpRequest();
        req.open('GET', this.traceDataUrl, true);

        req.onreadystatechange = (event) => {
          if (req.readyState !== 4) {
            return;
          }
          window.setTimeout(() => {
            if (req.status === 200) {
              this._throbber.className = 'inactive';
              this.set('_traceData', req.responseText);
            } else {
              this._displayOverlay(req.status, 'Failed to fetch data');
            }
          }, 0);
        };
        req.send(null);
      } else {
        this._loadStreamingTrace(requestedRange, replaceModel);
      }
    },

    // Something has changed, so consider reloading the data:
    //   - if we have zoomed in enough to need more detail
    //   - if we have scrolled too close to missing data regions
    // We ensure there's only ever one request in flight.
    _maybeLoad: function() {
      if (this._isLoading || this._resolution == 0) return;
      // We have several ranges of interest:
      //             [viewport]           - what's on-screen
      //         [----preserve----]       - issue loads to keep this full of data
      //     [---------fetch----------]   - fetch this much data with each load
      // [-----------full bounds--------] - the whole profile
      var viewport = this._trackViewRange(this._traceViewer.trackView);
      var PRESERVE_RATIO = tf_component_traceviewer.PRESERVE_RATIO;
      var preserve = tf_component_traceviewer.intersect(
        tf_component_traceviewer.expand(viewport, PRESERVE_RATIO),
        this._fullBounds
      );
      var FETCH_RATIO = tf_component_traceviewer.FETCH_RATIO;
      var fetch = tf_component_traceviewer.expand(viewport, FETCH_RATIO);
      var zoomFactor =
        tf_component_traceviewer.length(this._loadedRange) /
        tf_component_traceviewer.length(fetch);
      if (
        !tf_component_traceviewer.within(preserve, this._loadedRange) ||
        zoomFactor > tf_component_traceviewer.ZOOM_RATIO
      ) {
        this._loadTrace(fetch, /*replaceModel=*/ false);
      }
    },

    _loadStreamingTrace: function(requestedRange, replaceModel) {
      var success = true;
      this._isLoading = true;

      this._loadJSON(requestedRange)
        .then((data) => {
          this._updateModel(data, replaceModel);
        })
        .then(() => {
          this._updateView(requestedRange);
        })
        .catch((err) => {
          this._displayOverlay('Trace Viewer', err);
        })
        .then(() => {
          this._isLoading = false;
          this._throbber.className = 'inactive';
          // Don't immediately load new data after the very first load. When
          // we first load the trace viewer, the actual view is not properly
          // initialized and we get an incorrect viewport leading to a spurious
          // load of data.
          if (success && requestedRange) this._maybeLoad();
        });
    },

    // Loads a time window (the whole trace if requestedRange is null).
    // Returns a promise for the JSON event data.
    _loadJSON: function(requestedRange) {
      // Set up an XMLHTTPRequest to the JSON endpoint, populating range and
      // resolution if appropriate.
      var requestURL = this._buildBaseURL();
      var ZOOM_RATIO = tf_component_traceviewer.ZOOM_RATIO;
      if (requestURL.searchParams.has('selected_group_ids')) {
        requestURL.searchParams.set('resolution', 0);
      } else if (!requestURL.searchParams.has('resolution')) {
        requestURL.searchParams.set('resolution', this._resolution * ZOOM_RATIO);
      }
      if (requestedRange != null) {
        requestURL.searchParams.set('start_time_ms', requestedRange.min);
        requestURL.searchParams.set('end_time_ms', requestedRange.max);
      }

      return new Promise(function(resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', requestURL);
        xhr.onload = function() {
          var contentType = this.getResponseHeader('Content-Type');
          if (
            this.status !== 200 ||
            !contentType.startsWith('application/json')
          ) {
            var msg = requestURL + ' could not be loaded';
            if (contentType.startsWith('text/plain')) {
              msg = msg + ': ' + xhr.statusText;
            }
            reject(msg);
          }
          resolve(xhr.response);
        };
        xhr.onerror = function() {
          reject(requestURL + 'could not be loaded: ' + xhr.statusText);
        };
        xhr.send();
      });
    },

    // Decodes the JSON trace events, removes all events that were loaded before
    // and serializes to JSON again.
    _filterKnownTraceEvents: function(traceEvents) {
      if (this._loadedTraceEvents.size == 0) {
        for (let event of traceEvents) {
          const key = JSON.stringify(event);
          this._loadedTraceEvents.add(key);
        }
        return traceEvents;
      } else {
        let filteredTraceEvents = [];
        for (let event of traceEvents) {
          const key = JSON.stringify(event);
          if (!this._loadedTraceEvents.has(key)) {
            this._loadedTraceEvents.add(key);
            filteredTraceEvents.push(event);
          }
        }
        return filteredTraceEvents;
      }
    },

    _registerTraceFilterFieldForm: function(form, onCreate, onDelete) {
      form.addEventListener('submit', (event) => {
        event.preventDefault();
        const valueList = form.querySelector('ul');

        const valueText = onCreate(form);
        const valueLabel = document.createElement('li');

        const valueDeleteBtn = document.createElement('input');
        valueDeleteBtn.setAttribute('type', 'submit');
        valueDeleteBtn.setAttribute('class', 'delete-btn');
        valueDeleteBtn.value = "x";
        valueDeleteBtn.addEventListener('click', (event) => {
          event.preventDefault();
          onDelete(valueText);
          valueList.removeChild(valueLabel);
        });

        valueLabel.appendChild(valueDeleteBtn);
        valueLabel.appendChild(document.createTextNode(valueText));

        valueList.appendChild(valueLabel);
      });
    },

    _registerTraceFilterForm: function(createdTraceFilterDialog, traceFilterConfig) {
      const traceFilter = new TraceFilter();
      traceFilterConfig.trace_filters.push(traceFilter);

      const invertTraceFilterCheckBox = createdTraceFilterDialog.querySelector('.invert-tracefilter');
      invertTraceFilterCheckBox.addEventListener('change', (event) => {
        if (invertTraceFilterCheckBox.checked) {
          traceFilter.negation = true;
        } else {
          traceFilter.negation = false;
        }
      });

      createdTraceFilterDialog.querySelector('.delete-tracefilter').addEventListener('click',
        (event) => {
        traceFiltersList = document.querySelector('#created-trace-filter');
        traceFiltersList.removeChild(createdTraceFilterDialog);

        // Remove this TraceFilter from TraceFilterConfig.
        const index = traceFilterConfig.trace_filters.indexOf(traceFilter);
        if (index != -1) {
          traceFilterConfig.trace_filters.splice(index, 1);
        }
      });

      const regexOnCreate = (regexes, form) => {
        const fieldInput = form.querySelector('input[type="text"]');
        regexes.push(fieldInput.value);
        return fieldInput.value;
      };

      const regexOnDelete = (regexes, valueText) => {
        const index = regexes.indexOf(valueText);
        if (index != -1) {
          regexes.splice(index, 1);
        }
      };

      const eventFilterOnCreate = (eventFilters, form) => {
        const fieldNameInput = form.querySelector('input[name="field"]');
        const negationInput = form.querySelector('select[name="negation"]');
        const operatorInput = form.querySelector('select[name="operator"]');
        const valueInput = form.querySelector('input[name="value"]');
        const valueTypeInput = form.querySelector('select[name="value_type"]');

        const traceEventFilter = new TraceEventFilter(fieldNameInput.value,
                                                      Boolean(Number(negationInput.value)),
                                                      Number(operatorInput.value),
                                                      valueInput.value,
                                                      valueTypeInput.value);
        eventFilters.push(traceEventFilter);

        return traceEventFilter.toString();
      };

      const eventFilterOnDelete = (eventFilters, valueText) => {
        let foundIndex = -1;
        for (let i = 0; i < eventFilters.length; i++) {
          if (eventFilters[i].toString() == valueText) {
            foundIndex = i;
            break;
          }
        }

        if (foundIndex != -1) {
          eventFilters.splice(foundIndex, 1);
        }
      };

      const deviceRegexForm = createdTraceFilterDialog.querySelector('.device-regex-form');
      this._registerTraceFilterFieldForm(deviceRegexForm,
                        (form) => {return regexOnCreate(traceFilter.device_regexes, form)},
                        (valueText) => {regexOnDelete(traceFilter.device_regexes, valueText)});

      const resourceRegexForm = createdTraceFilterDialog.querySelector('.resource-regex-form');
      this._registerTraceFilterFieldForm(resourceRegexForm,
                        (form) => {return regexOnCreate(traceFilter.resource_regexes, form)},
                        (valueText) => {regexOnDelete(traceFilter.resource_regexes, valueText)});

      const eventRegexForm = createdTraceFilterDialog.querySelector('.event-regex-form');
      this._registerTraceFilterFieldForm(eventRegexForm,
                        (form) => {return eventFilterOnCreate(traceFilter.trace_event_filters,
                                                              form)},
                        (valueText) => {eventFilterOnDelete(traceFilter.trace_event_filters,
                                                            valueText)});

      const eventArgRegexForm = createdTraceFilterDialog.querySelector('.event-arg-regex-form');
      this._registerTraceFilterFieldForm(eventArgRegexForm,
                        (form) => {return eventFilterOnCreate(traceFilter.trace_event_arg_filters,
                                                              form)},
                        (valueText) => {eventFilterOnDelete(traceFilter.trace_event_arg_filters,
                                                            valueText)});
    },

    _createFilterSelector: function() {
      const filterSelector = document.createElement('tr-ui-b-dropdown');
      filterSelector.setAttribute('id', 'filter_selector');
      Polymer.dom(this._traceViewer.leftControls).appendChild(filterSelector);

      filterSelector.label = "Trace Filter Config";
      const filterDialog = filterSelector.getElementsByTagName('dialog')[0];

      filterDialog.innerHTML = `
        <div id="trace-filter-config">
        <div id="created-trace-filter">
        </div>
        <br>
        <input type="submit" id="create-trace-filter" value="Create TraceFilter">
        <br>
        <input type="checkbox" name="toggle-tracefilter-config">
        <label for="toggle-tracefilter-config">Apply Trace Filter Config</label>
        </div>
      `;

      filterSelector.style.display = 'flex';

      document.querySelector('input[name="toggle-tracefilter-config"]').addEventListener('change',
        (event) => {
          this._loadTrace(null, /* replaceModel= */ true);  // reload data.
      });

      const createTraceFilterButton = document.querySelector('#create-trace-filter');
      createTraceFilterButton.addEventListener('click', (event) => {
        traceFiltersList = document.querySelector('#created-trace-filter');

        traceFiltersList.insertAdjacentHTML('beforeend', traceFilterHTMLTemplate);
        createdTraceFilterDialog = traceFiltersList.children[traceFiltersList.children.length - 1];

        this._registerTraceFilterForm(createdTraceFilterDialog, this._traceFilterConfig);
      });
    },

    // Updates the model with data returned by the JSON endpoint.
    // If replaceModel is true, the data set is completely replaced; otherwise,
    // the new data is merged with the old data.
    // Returns a void promise.
    _updateModel: function(data, replaceModel) {
      data = JSON.parse(data);
      if (!this._model /* first load */ || replaceModel) {
        this._dirty = true;
        this._model = new tr.Model();
        this._loadedTraceEvents = new Set();
      } else {
        // Delete fields to prevent traceviewer from accumulating them.
        delete data['metadata'];
        delete data['displayTimeUnit'];
        delete data['tasks'];
      }

      // Populate and show "details" selector.
      if (data['details']) {
        const detailsSelector = document.getElementById('details_selector');
        detailsSelector.label = "Details";
        const detailsDialog = detailsSelector.getElementsByTagName('dialog')[0];
        data['details'].forEach(detail => {
          let checkbox = detailsDialog.querySelector('#' + detail.name);
          if (checkbox) {
            checkbox.checked = detail.value;
            return;
          }
          const checkboxDiv = document.createElement('div');
          checkbox = document.createElement('input');
          checkbox.setAttribute('type', 'checkbox');
          checkbox.setAttribute('id', detail.name);
          checkbox.setAttribute('name', detail.name);
          checkbox.checked = detail.value;
          checkbox.addEventListener('change', () => {
            this._loadTrace(null, /* replaceModel= */ true);  // reload data.
          });
          checkboxDiv.appendChild(checkbox);
          const checkboxLabel = document.createElement('label');
          checkboxLabel.setAttribute('for', detail.name);
          checkboxLabel.style.textTransform = 'capitalize';
          checkboxLabel.innerText = detail.name.replace(/_/g, ' ');
          checkboxDiv.appendChild(checkboxLabel);
          detailsDialog.appendChild(checkboxDiv);
        });
        detailsSelector.style.display = 'flex';
        delete data['details'];
      }

      if (data['selected_device_ids']) {
        this._selectedDeviceIds = data['selected_device_ids'];
        delete data['selected_device_ids'];
      } else {
        this._selectedDeviceIds = null;
      }

      data.traceEvents = this._filterKnownTraceEvents(data.traceEvents);
      if (data.traceEvents.length > 0) {
        var opt = new tr.importer.ImportOptions();
        opt.shiftWorldToZero = false;
        new tr.importer.Import(this._model, opt).importTraces([data]);
        this._dirty = true;
      }

      this._devices = {};
      for (const pid in this._model.processes) {
        this._devices[pid] = this._model.processes[pid].name;
      }

      return Promise.resolve();
    },

    // Remove all checkboxes in the Process Filter Dropdown.
    _clearProcessList: function() {
      const dropdown = Polymer.dom(document.getElementById("process_filter_dropdown"));
      while (dropdown.firstChild) {
        dropdown.removeChild(dropdown.firstChild);
      }
    },

    // Only for XProf Streaming Mode we need to define our own _updateProcessList()
    // instead of using the Catapult timeline_view.html _updateProcessList() to
    // create the Process Filter Dropdown.
    // Ref: http://cs/github/catapult-project/catapult/tracing/tracing/ui/timeline_view.html?l=433
    //
    // In our implementation, for every process checkbox on change event for
    // select/deselect process, we call this._loadTrace(...) to load a new trace using the url with
    // the "selected_device_ids" query parameter populated from the process filter dropdown
    // selection.
    //
    // If this._selectedDeviceIds is set from the data["selected_device_ids"] from the Trace JSON
    // we only check pids that are in "selected_device_ids". This means Process Filter Dropdown
    // should be consistent even as the user zooms/pans and new Trace JSON is loaded.
    _updateProcessList: function() {
      let selectedDeviceIds;
      if (this._selectedDeviceIds !== null) {
        selectedDeviceIds = this._selectedDeviceIds.map((id) => id.toString());
      } else {
        selectedDeviceIds = Object.keys(this._devices);
      }

      this._clearProcessList();

      const cboxes = [];
      const updateAll = (checked) => {
        for (const cbox of cboxes) {
          cbox.checked = checked;
        }
      };

      const dropdown = Polymer.dom(document.getElementById("process_filter_dropdown"));
      dropdown.appendChild(tr.ui.b.createButton('All', () => {
        updateAll(true);
        this._loadTrace(null, /* replaceModel= */ true);  // reload data.
      }));
      dropdown.appendChild(tr.ui.b.createButton('None', () => {
        updateAll(false);
        this._loadTrace(null, /* replaceModel= */ true);  // reload data.
      }));

      for (const pid in this._devices) {
        const cbox = tr.ui.b.createCheckBox(undefined, undefined, undefined,
            true, `${this._devices[pid]} (pid ${pid})`);

        cbox.checked = selectedDeviceIds.includes(pid);
        cbox.addEventListener('change', () => {
          this._loadTrace(null, /* replaceModel= */ true);  // reload data.
        });

        cboxes.push(cbox);
        dropdown.appendChild(cbox);
      }
    },

    // Updates the view based on the current model.
    _updateView: function(requestedRange) {
      if (requestedRange == null) {
        this._fullBounds = {
          min: this._model.bounds.min,
          max: this._model.bounds.max,
        };
        this._loadedRange = tf_component_traceviewer.expand(
          this._fullBounds,
          tf_component_traceviewer.FETCH_RATIO
        );
      } else {
        this._loadedRange = requestedRange;
      }
      if (!this._dirty) {
        return;
      }
      this._dirty = false;
      // We can't assign the model until the viewer is attached. This may be
      // delayed indefinitely if the tab is backgrounded. This version of polymer
      // doesn't provide a direct way to observe the viewer being attached.
      // This is a workaround: the browser won't paint until the viewer is attached.
      window.requestAnimationFrame(
        function() {
          this._traceViewer.model = this._model;
          if (this._traceViewer.trackView != null) {
            // Only initialized if data in nonempty!
            // Wait 200ms to let an animated zoom/pan operation complete. Ideally,
            // we could just explicitly wait for its end.

            this._traceViewer.trackView.viewport.addEventListener(
              'change',
              () => setTimeout(this._maybeLoad.bind(this), 200)
            );
          }
          this._traceViewer.viewTitle = '';
        }.bind(this)
      );
    },

    // Access the {min, max} range of a trackView.
    _trackViewRange: function(trackView) {
      var xfm = trackView.viewport.currentDisplayTransform;
      const pixelRatio = window.devicePixelRatio || 1;
      const devicePixelWidth = pixelRatio * trackView.viewWidth_;
      return {
        min: xfm.xViewToWorld(0),
        max: xfm.xViewToWorld(devicePixelWidth),
      };
    },

    // Returns the resolution (in number of events) given the width of the
    // trace viewer (in pixels).
    _resolutionFromViewerWidth(viewerWidth) {
      const pixelRatio = window.devicePixelRatio || 1;
      const minEventWidth = 2 * pixelRatio;
      viewerWidth -= tr.ui.b.constants.HEADING_WIDTH;  // substract row header
      viewerWidth *= pixelRatio;  // adjust pixel ratio
      return Math.round(viewerWidth / minEventWidth);
    },

    // Builds a base URL for fetching json data. The URL will be assembled with
    // all filtering URL parameters, except resolution and range.
    _buildBaseURL: function() {
      const requestURL = new URL(this.traceDataUrl, window.location.href);
      const hostSelector = document.getElementById("host_selector");
      const host = hostSelector.options[hostSelector.selectedIndex];
      // Don't set "host" parameter for "all hosts".
      if (host.value) requestURL.searchParams.set(hostSelector.name, host.value);
      const detailsSelector = document.getElementById("details_selector");
      const detailsDialog = detailsSelector.getElementsByTagName('dialog')[0];
      const checkboxDivs = detailsDialog.getElementsByTagName('div');
      for (let i = 0; i < checkboxDivs.length; ++i) {
        const checkbox = checkboxDivs[i].getElementsByTagName('input')[0];
        requestURL.searchParams.set(checkbox.name, checkbox.checked);
      }

      // Populate query parameter "selected_device_ids".
      const dropdown = Polymer.dom(document.getElementById("process_filter_dropdown"));
      const selectedDeviceIds = [];
      // Checkbox nodes start at index 2 since the first two nodes are the "All" and "None" button.
      for (let i = 2; i < dropdown.childNodes.length; ++i) {
        const checkbox = dropdown.childNodes[i].getElementsByTagName('input')[0];
        if (checkbox.checked) {
          const label = dropdown.childNodes[i].getElementsByTagName('label')[0];
          const pid = label.innerText.match(/pid (\d+)/)[1];
          selectedDeviceIds.push(pid)
        }
      }

      // Only send "selected_device_ids" query param when Process Filter Dropdown is populated
      // with a list of devices (pids) checkboxes.
      if (dropdown.childNodes.length > 2) {
        requestURL.searchParams.set('selected_device_ids', selectedDeviceIds.join(','));
      }

      // Only send "trace_filter_config" query param when the "Apply TraceFilter Config" checkbox
      // is toggled on.
      if (document.querySelector('input[name="toggle-tracefilter-config"]').checked) {
        requestURL.searchParams.set('trace_filter_config', JSON.stringify(this._traceFilterConfig));
      }

      if (requestURL.searchParams.has('use_saved_result')) {
        if (this._dataRegenerated) {
          requestURL.searchParams.delete('use_saved_result');
        } else {
          this._dataRegenerated = true;
        }
      }
      return requestURL;
    },

    _traceDataChanged: function(data) {
      if (!data) {
        this._displayOverlay('Trace Viewer', 'No trace to display...');
        return;
      }
      // Feed the trace data into the trace viewer app.
      this._traceModel = new tr.Model();
      var i = new tr.importer.Import(this._traceModel);
      var p = i.importTracesWithProgressDialog([data]);
      p.then(() => {
        this._traceViewer.model = this._traceModel;
        this._traceViewer.viewTitle = 'Trace View';
      }).catch((err) => {
        this._displayOverlay(
          'Import error',
          tr.b.normalizeException(err).message
        );
      });
    },

    _displayOverlay: function(title, content) {
      var overlay = new tr.ui.b.Overlay();
      overlay.textContent = content;
      overlay.title = title;
      overlay.visible = true;
    },
  });
</script>
